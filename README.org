#+TITLE: cl-state-machine
#+AUTHOR: Jonghyouk Yun


#+CAPTION: Example State Machine, defined in cl-state-machine
#+NAME:   fig:Example-State-Machine.png
[[./doc/ya-tamagochi.png]]


Simple state machine DSL/library for CommonLisp.

  1) Define state machines in DSL.
  2) Wire with external object by attaching hook functions.


* Getting Started

  ~git clone git@github.com:ageldama/cl-state-machine.git~

  ..And then:


  #+BEGIN_SRC lisp
    ;;; Load this system. (You need Quicklisp and up to date ASDF v3.3+)
    ;;;      - in case no idea how ASDF finds `cl-state-machine.asd' file on your disk:
    ;;;        https://common-lisp.net/project/asdf/asdf/Configuring-ASDF-to-find-your-systems.html
    ;;;
    (ql:quickload :cl-state-machine)


    ;;; (Optional, Run tests)
    ;;;
    (asdf:test-system :cl-state-machine)


    ;;; (Optional, Run example program)
    ;;;
    (asdf:load-system :cl-state-machine-examples)
    (cl-state-machine-examples/tamagochi:run)
  #+END_SRC


* Basic Usages
  * I will omit the package name ~cl-state-machine:~ in every example
    codes below. (Consider every external symbol has been imported to
    your working package)

** Defining a State Machine
   #+BEGIN_SRC lisp
     ;;; Using `state-machine-of' DSL macro:
     ;;;
     (state-machine-of `(:current-state :HOME)
                       (`(:state :HOME)
                         `(:state :FIN :terminal t)
                         `(:state :WORK))
                       (`(:from :START :to :WORK
                          :event :HOME->WORK)
                         `(:from :WORK :to :HOME
                           :event :WORK->HOME)
                         `(:from :HOME :to :FIN
                           :event :HOME->FIN)))

     ;;; Or without using DSL:
     ;;;
     (let* (;; states
            (state-home (make-instance 'state-definition :state :HOME))
            (state-work (make-instance 'state-definition :state :WORK))
            (state-fin (make-instance 'state-definition :state :FIN :terminal t))
            ;; events
            (event-home->work (make-instance 'transition-definition
                                             :from :HOME :to :WORK
                                             :event :HOME->WORK))
            (event-work->home (make-instance 'transition-definition
                                             :from :WORK :to :HOME
                                             :event :WORK->HOME))
            (event-home->fin (make-instance 'transition-definition
                                            :from :HOME :to :FIN
                                            :event :HOME->FIN))
            ;; state-machine
            (a-state-machine (make-instance 'state-machine
                                            :state-definitions (list state-home
                                                                     state-work
                                                                     state-fin)
                                            :transition-definitions (list event-home->work
                                                                          event-work->home
                                                                          event-home->fin)
                                            :current-state :HOME)))
       ;; ...Your code here...
       nil)


     ;;; ...Exactly equivalent definitions
   #+END_SRC

*** Type ~before-hook-function~ and ~after-hook-function~
    Hook functions can be attached to:

    1) state machine instance
    2) state definition
    3) transition definition

    And those will be invoked when attached
    state-machine/state/transition's getting activation, on the before
    and the after.

    #+BEGIN_SRC lisp
      ;;; Both does not return any value,
      ;;;
      ;;; And take `state-transition' of current event.
      ;;;
      ;;; Also can take auxiliary values by `&rest t' which has been passed
      ;;; by event initiator.
      ;;;
      (deftype before-hook-function ()
        `(function (state-transition &rest t) null))

      (deftype after-hook-function ()
        `(function (state-transition &rest t) null))


      ;;; Thus, it would look like:
      (flet ((a-before-hook (a-state-definition &rest args) nil)
             (an-after-hook (a-state-definition &rest args) nil))
        nil)
    #+END_SRC

*** Class ~state-definition~
    #+BEGIN_SRC lisp
      (make-instance 'state-definition
                     :state :FIN    ; Name of this state

                     :terminal t    ; Is a terminal state? Optional, Default: false.

                     :description "foo????"    ; Simple descriptive string. Optional.

                     ;; Hook function slots are list of functions:
                     ;; (Read above `Hook functions' section)
                     ;;
                     ;; Optional.
                     :before-hooks (list #'a-before-hook-fn)

                     :after-hooks (list #'a-after-hook-fn
                                        #'another-after-hook-fn))
    #+END_SRC

*** Macro ~state-definitions-of~
    #+BEGIN_SRC lisp
      ;;; Can express a list of `state-definition's easily:
      (state-definitions-of
       '(:state :a) ; simply `initarg' of `state-definition'.
       `(:state :b
         :terminal t
         :before-hooks (,#'a-before-hook-fn))) ; Use of quasiquotes
    #+END_SRC

*** Class ~transition-definition~
    #+BEGIN_SRC lisp
      (make-instance 'transition-definition
                     :from :STARTING-STATE :to :END-STATE

                     :event :END-IT   ; the `transition-definition' triggered by this `:event'-keyword

                     :description "Hasta la vista, baby." ; Optional

                     :before-hooks (list #'a-before-hook-fn
                                         #'another-before-hook-fn)
                     :after-hooks '())
    #+END_SRC


*** Macro ~transition-definitions-of~
    #+BEGIN_SRC lisp
       (transition-definitions-of
        '(:from :A :to :B :event :A->B)
        '(:from :B :to :A :event :B->A)
        `(:from :A :to :C :event :A->C
          :description "yet another foobar????"
          :before-hooks (,#'a-before-hook-fn)))
    #+END_SRC

*** Class ~state-machine~
    1) ~state-definitions~
    2) ~current-state~
    3) ~transition-definitions~
    4) ~before-hooks~ and ~after-hooks~
    5) ~datum~

*** Macro ~state-machine-of~



** TODO Predicates and Inquries

*** Function ~can?~

*** Function ~terminated?~

*** Function ~possible-events~



** TODO State Changings

*** Function ~jump!~

*** Function ~trigger!~



** TODO More on Hooks

*** Function ~reject-transition!~
    - ..and ~trigger!~




* TODO Advanced Usages


** Predicates and Inquries

*** Function ~find-state-definition-by-state~

*** Function ~find-transition-definition-by-state-and-event~




** Scheduling Next Trigger Steps

*** Function ~schedule-next-trigger*~, Hooks, and ~trigger!~ Function

*** Function ~empty-next-trigger-schedules~

*** ~*trigger-schedules*~, ~trigger-schedule-entry-event~, ~trigger-schedule-entry-args~

*** Function ~compute-last-state~


** Trigger History

*** Variable ~*trigger-history*~

*** Variable ~*trigger!-clear-history?~ and ~trigger!~ Function

** TODO Macro: ~with-own-trigger-schedule-and-history~





* Do Not Share Among Threads
  Every object and function in this system does not prevent multi
  threading issues. Thus please do not share any instance value
  between multiple threads, state transition and all other mutating
  operations should be invoked and executed within same thread.

* Contact and License
  - Keybase: [[https://keybase.io/ageldama]]
  - Licensed under MIT License. (Read ~LICENSE~ file)
